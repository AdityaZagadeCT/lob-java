<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IntlVerification.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">lob-java</a> &gt; <a href="index.source.html" class="el_package">org.openapitools.client.model</a> &gt; <span class="el_source">IntlVerification.java</span></div><h1>IntlVerification.java</h1><pre class="source lang-java linenums">/*
 * Lob
 * The Lob API is organized around REST. Our API is designed to have predictable, resource-oriented URLs and uses HTTP response codes to indicate any API errors. &lt;p&gt; Looking for our [previous documentation](https://lob.github.io/legacy-docs/)? 
 *
 * The version of the OpenAPI document: 1.3.0
 * Contact: lob-openapi@lob.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import org.openapitools.client.model.IntlComponents;
import org.openapitools.jackson.nullable.JsonNullable;

/**
 * IntlVerification
 */
@javax.annotation.Generated(value = &quot;org.openapitools.codegen.languages.JavaClientCodegen&quot;)
<span class="fc" id="L33">public class IntlVerification {</span>
  public static final String SERIALIZED_NAME_ID = &quot;id&quot;;

  @SerializedName(SERIALIZED_NAME_ID)
  

  private String id;

  /**
  * Unique identifier prefixed with `intl_ver_`.
  * @return id
  **/
  
  @javax.annotation.Nullable
  
<span class="fc" id="L48">  public String getId() { return id; }</span>

  public void setId (String id) throws IllegalArgumentException {
<span class="fc bfc" id="L51" title="All 2 branches covered.">    if(!id.matches(&quot;^intl_ver_[a-zA-Z0-9]+$&quot;)) {</span>
<span class="fc" id="L52">      throw new IllegalArgumentException(&quot;Invalid id provided&quot;);</span>
    }

<span class="fc" id="L55">    this.id = id;</span>
<span class="fc" id="L56">  }</span>
  
  

  public static final String SERIALIZED_NAME_RECIPIENT = &quot;recipient&quot;;

  @SerializedName(SERIALIZED_NAME_RECIPIENT)
  

  private String recipient;

  /**
  * The intended recipient, typically a person's or firm's name.
  * @return recipient
  **/
  
  @javax.annotation.Nullable
  
  @ApiModelProperty(value = &quot;The intended recipient, typically a person's or firm's name.&quot;)
  
  public String getRecipient() {
<span class="fc" id="L77">      return recipient;</span>
  }
  
  

  public static final String SERIALIZED_NAME_PRIMARY_LINE = &quot;primary_line&quot;;

  @SerializedName(SERIALIZED_NAME_PRIMARY_LINE)
  

  private String primaryLine;

  /**
  * The primary delivery line (usually the street address) of the address. 
  * @return primaryLine
  **/
  
  @javax.annotation.Nullable
  
  @ApiModelProperty(value = &quot;The primary delivery line (usually the street address) of the address. &quot;)
  
  public String getPrimaryLine() {
<span class="fc" id="L99">      return primaryLine;</span>
  }
  
  

  public static final String SERIALIZED_NAME_SECONDARY_LINE = &quot;secondary_line&quot;;

  @SerializedName(SERIALIZED_NAME_SECONDARY_LINE)
  

  private String secondaryLine;

  /**
  * The secondary delivery line of the address. This field is typically empty but may contain information if `primary_line` is too long. 
  * @return secondaryLine
  **/
  
  @javax.annotation.Nullable
  
  @ApiModelProperty(value = &quot;The secondary delivery line of the address. This field is typically empty but may contain information if `primary_line` is too long. &quot;)
  
  public String getSecondaryLine() {
<span class="fc" id="L121">      return secondaryLine;</span>
  }
  
  

  public static final String SERIALIZED_NAME_LAST_LINE = &quot;last_line&quot;;

  @SerializedName(SERIALIZED_NAME_LAST_LINE)
  

  private String lastLine;

  /**
  * Combination of the following applicable `components`: * `city` * `state` * `zip_code` * `zip_code_plus_4` 
  * @return lastLine
  **/
  
  @javax.annotation.Nullable
  
  @ApiModelProperty(value = &quot;Combination of the following applicable `components`: * `city` * `state` * `zip_code` * `zip_code_plus_4` &quot;)
  
  public String getLastLine() {
<span class="fc" id="L143">      return lastLine;</span>
  }
  
  

  public static final String SERIALIZED_NAME_COUNTRY = &quot;country&quot;;

  @SerializedName(SERIALIZED_NAME_COUNTRY)
  

  private String country;

  /**
  * The country of the address. Will be returned as a 2 letter country short-name code (ISO 3166).
  * @return country
  **/
  
  @javax.annotation.Nullable
  
  @ApiModelProperty(value = &quot;The country of the address. Will be returned as a 2 letter country short-name code (ISO 3166).&quot;)
  
  public String getCountry() {
<span class="fc" id="L165">      return country;</span>
  }
  
  

  /**
   * The coverage level for the country. This represents the maximum level of accuracy an input address can be verified to.  * &amp;#x60;SUBBUILDING&amp;#x60; - Coverage down to unit numbers. For example, in an apartment or a large building * &amp;#x60;HOUSENUMBER/BUILDING&amp;#x60; - Coverage down to house number. For example, the address where a house or building may be located * &amp;#x60;STREET&amp;#x60; - Coverage down to street. This means that we can verify that an street exists in a city, state, country * &amp;#x60;LOCALITY&amp;#x60; - Coverage down to city, state, or village or province. This means that we can verify that a city, village, province, or state exists in a country. Countries differ in how they define what is a province, state, city, village, etc. This attempts to group eveyrthing together. * &amp;#x60;SPARSE&amp;#x60; - Some addresses for this country exist in our databases 
   */
  @JsonAdapter(CoverageEnum.Adapter.class)
<span class="fc" id="L174">  public enum CoverageEnum {</span>
<span class="fc" id="L175">    SUBBUILDING(&quot;SUBBUILDING&quot;),</span>
    
<span class="fc" id="L177">    HOUSENUMBER_BUILDING(&quot;HOUSENUMBER/BUILDING&quot;),</span>
    
<span class="fc" id="L179">    STREET(&quot;STREET&quot;),</span>
    
<span class="fc" id="L181">    LOCALITY(&quot;LOCALITY&quot;),</span>
    
<span class="fc" id="L183">    SPARSE(&quot;SPARSE&quot;);</span>

    private String value;

<span class="fc" id="L187">    CoverageEnum(String value) {</span>
<span class="fc" id="L188">      this.value = value;</span>
<span class="fc" id="L189">    }</span>

    public String getValue() {
<span class="nc" id="L192">      return value;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L197">      return String.valueOf(value);</span>
    }

    public static CoverageEnum fromValue(String value) {
<span class="nc bnc" id="L201" title="All 2 branches missed.">      for (CoverageEnum b : CoverageEnum.values()) {</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">        if (b.value.equals(value)) {</span>
<span class="nc" id="L203">          return b;</span>
        }
      }
<span class="nc" id="L206">      throw new IllegalArgumentException(&quot;Unexpected value '&quot; + value + &quot;'&quot;);</span>
    }

<span class="nc" id="L209">    public static class Adapter extends TypeAdapter&lt;CoverageEnum&gt; {</span>
      @Override
      public void write(final JsonWriter jsonWriter, final CoverageEnum enumeration) throws IOException {
<span class="nc" id="L212">        jsonWriter.value(enumeration.getValue());</span>
<span class="nc" id="L213">      }</span>

      @Override
      public CoverageEnum read(final JsonReader jsonReader) throws IOException {
<span class="nc" id="L217">        String value =  jsonReader.nextString();</span>
<span class="nc" id="L218">        return CoverageEnum.fromValue(value);</span>
      }
    }
  }

  public static final String SERIALIZED_NAME_COVERAGE = &quot;coverage&quot;;

  @SerializedName(SERIALIZED_NAME_COVERAGE)
  

  private CoverageEnum coverage;

  /**
  * The coverage level for the country. This represents the maximum level of accuracy an input address can be verified to.  * `SUBBUILDING` - Coverage down to unit numbers. For example, in an apartment or a large building * `HOUSENUMBER/BUILDING` - Coverage down to house number. For example, the address where a house or building may be located * `STREET` - Coverage down to street. This means that we can verify that an street exists in a city, state, country * `LOCALITY` - Coverage down to city, state, or village or province. This means that we can verify that a city, village, province, or state exists in a country. Countries differ in how they define what is a province, state, city, village, etc. This attempts to group eveyrthing together. * `SPARSE` - Some addresses for this country exist in our databases 
  * @return coverage
  **/
  
  @javax.annotation.Nullable
  
  @ApiModelProperty(value = &quot;The coverage level for the country. This represents the maximum level of accuracy an input address can be verified to.  * `SUBBUILDING` - Coverage down to unit numbers. For example, in an apartment or a large building * `HOUSENUMBER/BUILDING` - Coverage down to house number. For example, the address where a house or building may be located * `STREET` - Coverage down to street. This means that we can verify that an street exists in a city, state, country * `LOCALITY` - Coverage down to city, state, or village or province. This means that we can verify that a city, village, province, or state exists in a country. Countries differ in how they define what is a province, state, city, village, etc. This attempts to group eveyrthing together. * `SPARSE` - Some addresses for this country exist in our databases &quot;)
  
  public CoverageEnum getCoverage() {
<span class="fc" id="L240">      return coverage;</span>
  }
  
  

  /**
   * Summarizes the deliverability of the &amp;#x60;intl_verification&amp;#x60; object. Possible values are: * &amp;#x60;deliverable&amp;#x60; — The address is deliverable. * &amp;#x60;deliverable_missing_info&amp;#x60; — The address is missing some information, but is most likely deliverable. * &amp;#x60;undeliverable&amp;#x60; — The address is most likely not deliverable. Some components of the address (such as city or postal code) may have been found. * &amp;#x60;no_match&amp;#x60; — This address is not deliverable. No matching street could be found within the city or postal code. 
   */
  @JsonAdapter(DeliverabilityEnum.Adapter.class)
<span class="fc" id="L249">  public enum DeliverabilityEnum {</span>
<span class="fc" id="L250">    DELIVERABLE(&quot;deliverable&quot;),</span>
    
<span class="fc" id="L252">    DELIVERABLE_MISSING_INFO(&quot;deliverable_missing_info&quot;),</span>
    
<span class="fc" id="L254">    UNDELIVERABLE(&quot;undeliverable&quot;),</span>
    
<span class="fc" id="L256">    NO_MATCH(&quot;no_match&quot;);</span>

    private String value;

<span class="fc" id="L260">    DeliverabilityEnum(String value) {</span>
<span class="fc" id="L261">      this.value = value;</span>
<span class="fc" id="L262">    }</span>

    public String getValue() {
<span class="nc" id="L265">      return value;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L270">      return String.valueOf(value);</span>
    }

    public static DeliverabilityEnum fromValue(String value) {
<span class="nc bnc" id="L274" title="All 2 branches missed.">      for (DeliverabilityEnum b : DeliverabilityEnum.values()) {</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">        if (b.value.equals(value)) {</span>
<span class="nc" id="L276">          return b;</span>
        }
      }
<span class="nc" id="L279">      throw new IllegalArgumentException(&quot;Unexpected value '&quot; + value + &quot;'&quot;);</span>
    }

<span class="nc" id="L282">    public static class Adapter extends TypeAdapter&lt;DeliverabilityEnum&gt; {</span>
      @Override
      public void write(final JsonWriter jsonWriter, final DeliverabilityEnum enumeration) throws IOException {
<span class="nc" id="L285">        jsonWriter.value(enumeration.getValue());</span>
<span class="nc" id="L286">      }</span>

      @Override
      public DeliverabilityEnum read(final JsonReader jsonReader) throws IOException {
<span class="nc" id="L290">        String value =  jsonReader.nextString();</span>
<span class="nc" id="L291">        return DeliverabilityEnum.fromValue(value);</span>
      }
    }
  }

  public static final String SERIALIZED_NAME_DELIVERABILITY = &quot;deliverability&quot;;

  @SerializedName(SERIALIZED_NAME_DELIVERABILITY)
  

  private DeliverabilityEnum deliverability;

  /**
  * Summarizes the deliverability of the `intl_verification` object. Possible values are: * `deliverable` — The address is deliverable. * `deliverable_missing_info` — The address is missing some information, but is most likely deliverable. * `undeliverable` — The address is most likely not deliverable. Some components of the address (such as city or postal code) may have been found. * `no_match` — This address is not deliverable. No matching street could be found within the city or postal code. 
  * @return deliverability
  **/
  
  @javax.annotation.Nullable
  
  @ApiModelProperty(value = &quot;Summarizes the deliverability of the `intl_verification` object. Possible values are: * `deliverable` — The address is deliverable. * `deliverable_missing_info` — The address is missing some information, but is most likely deliverable. * `undeliverable` — The address is most likely not deliverable. Some components of the address (such as city or postal code) may have been found. * `no_match` — This address is not deliverable. No matching street could be found within the city or postal code. &quot;)
  
  public DeliverabilityEnum getDeliverability() {
<span class="fc" id="L313">      return deliverability;</span>
  }
  
  

  /**
   * The status level for the country. This represents the maximum level of accuracy an input address can be verified to.  * &amp;#x60;LV4&amp;#x60; - Verified. The input data is correct. All input data was able to match in databases. * &amp;#x60;LV3&amp;#x60; - Verified. The input data is correct. All input data was able to match in databases &amp;lt;em&amp;gt;after&amp;lt;/em&amp;gt; some or all elements were standarized. The input data may also be using outdated city, state, or country names. * &amp;#x60;LV2&amp;#x60; - Verified. The input data is correct although some input data is unverifiable due to incomplete data. * &amp;#x60;LV1&amp;#x60; - Verified. The input data is acceptable but in an attempt to standarize user input, errors were introduced. * &amp;#x60;LF4&amp;#x60; - Fixed. The input data is matched and fixed. (Example: Brighon, UK -&amp;gt; Brighton, UK) * &amp;#x60;LF3&amp;#x60; - Fixed. The input data is matched and fixed but some elements such as Subbuilding number and house number cannot be checked. * &amp;#x60;LF2&amp;#x60; - Fixed. The input data is matched but some elements such as Street cannot be checked. * &amp;#x60;LF1&amp;#x60; - Fixed. The input data is acceptable but in an attempt to standarize user input, errors were introduced. * &amp;#x60;LM4&amp;#x60; - Missing Info. The input data cannot be corrected completely. * &amp;#x60;LM3&amp;#x60; - Missing Info. The input data cannot be corrected completely and there were multiple matches found in databases. * &amp;#x60;LM2&amp;#x60; - Missing Info. The input data cannot be corrected completely and only some elements were found. * &amp;#x60;LU1&amp;#x60; - Unverified. The input data cannot be corrected or matched. 
   */
  @JsonAdapter(StatusEnum.Adapter.class)
<span class="fc" id="L322">  public enum StatusEnum {</span>
<span class="fc" id="L323">    LV4(&quot;LV4&quot;),</span>
    
<span class="fc" id="L325">    LV3(&quot;LV3&quot;),</span>
    
<span class="fc" id="L327">    LV2(&quot;LV2&quot;),</span>
    
<span class="fc" id="L329">    LV1(&quot;LV1&quot;),</span>
    
<span class="fc" id="L331">    LF4(&quot;LF4&quot;),</span>
    
<span class="fc" id="L333">    LF3(&quot;LF3&quot;),</span>
    
<span class="fc" id="L335">    LF2(&quot;LF2&quot;),</span>
    
<span class="fc" id="L337">    LF1(&quot;LF1&quot;),</span>
    
<span class="fc" id="L339">    LM4(&quot;LM4&quot;),</span>
    
<span class="fc" id="L341">    LM3(&quot;LM3&quot;),</span>
    
<span class="fc" id="L343">    LM2(&quot;LM2&quot;),</span>
    
<span class="fc" id="L345">    LU1(&quot;LU1&quot;);</span>

    private String value;

<span class="fc" id="L349">    StatusEnum(String value) {</span>
<span class="fc" id="L350">      this.value = value;</span>
<span class="fc" id="L351">    }</span>

    public String getValue() {
<span class="nc" id="L354">      return value;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L359">      return String.valueOf(value);</span>
    }

    public static StatusEnum fromValue(String value) {
<span class="nc bnc" id="L363" title="All 2 branches missed.">      for (StatusEnum b : StatusEnum.values()) {</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">        if (b.value.equals(value)) {</span>
<span class="nc" id="L365">          return b;</span>
        }
      }
<span class="nc" id="L368">      throw new IllegalArgumentException(&quot;Unexpected value '&quot; + value + &quot;'&quot;);</span>
    }

<span class="nc" id="L371">    public static class Adapter extends TypeAdapter&lt;StatusEnum&gt; {</span>
      @Override
      public void write(final JsonWriter jsonWriter, final StatusEnum enumeration) throws IOException {
<span class="nc" id="L374">        jsonWriter.value(enumeration.getValue());</span>
<span class="nc" id="L375">      }</span>

      @Override
      public StatusEnum read(final JsonReader jsonReader) throws IOException {
<span class="nc" id="L379">        String value =  jsonReader.nextString();</span>
<span class="nc" id="L380">        return StatusEnum.fromValue(value);</span>
      }
    }
  }

  public static final String SERIALIZED_NAME_STATUS = &quot;status&quot;;

  @SerializedName(SERIALIZED_NAME_STATUS)
  

  private StatusEnum status;

  /**
  * The status level for the country. This represents the maximum level of accuracy an input address can be verified to.  * `LV4` - Verified. The input data is correct. All input data was able to match in databases. * `LV3` - Verified. The input data is correct. All input data was able to match in databases &lt;em&gt;after&lt;/em&gt; some or all elements were standarized. The input data may also be using outdated city, state, or country names. * `LV2` - Verified. The input data is correct although some input data is unverifiable due to incomplete data. * `LV1` - Verified. The input data is acceptable but in an attempt to standarize user input, errors were introduced. * `LF4` - Fixed. The input data is matched and fixed. (Example: Brighon, UK -&gt; Brighton, UK) * `LF3` - Fixed. The input data is matched and fixed but some elements such as Subbuilding number and house number cannot be checked. * `LF2` - Fixed. The input data is matched but some elements such as Street cannot be checked. * `LF1` - Fixed. The input data is acceptable but in an attempt to standarize user input, errors were introduced. * `LM4` - Missing Info. The input data cannot be corrected completely. * `LM3` - Missing Info. The input data cannot be corrected completely and there were multiple matches found in databases. * `LM2` - Missing Info. The input data cannot be corrected completely and only some elements were found. * `LU1` - Unverified. The input data cannot be corrected or matched. 
  * @return status
  **/
  
  @javax.annotation.Nullable
  
  @ApiModelProperty(value = &quot;The status level for the country. This represents the maximum level of accuracy an input address can be verified to.  * `LV4` - Verified. The input data is correct. All input data was able to match in databases. * `LV3` - Verified. The input data is correct. All input data was able to match in databases &lt;em&gt;after&lt;/em&gt; some or all elements were standarized. The input data may also be using outdated city, state, or country names. * `LV2` - Verified. The input data is correct although some input data is unverifiable due to incomplete data. * `LV1` - Verified. The input data is acceptable but in an attempt to standarize user input, errors were introduced. * `LF4` - Fixed. The input data is matched and fixed. (Example: Brighon, UK -&gt; Brighton, UK) * `LF3` - Fixed. The input data is matched and fixed but some elements such as Subbuilding number and house number cannot be checked. * `LF2` - Fixed. The input data is matched but some elements such as Street cannot be checked. * `LF1` - Fixed. The input data is acceptable but in an attempt to standarize user input, errors were introduced. * `LM4` - Missing Info. The input data cannot be corrected completely. * `LM3` - Missing Info. The input data cannot be corrected completely and there were multiple matches found in databases. * `LM2` - Missing Info. The input data cannot be corrected completely and only some elements were found. * `LU1` - Unverified. The input data cannot be corrected or matched. &quot;)
  
  public StatusEnum getStatus() {
<span class="fc" id="L402">      return status;</span>
  }
  
  

  public static final String SERIALIZED_NAME_COMPONENTS = &quot;components&quot;;

  @SerializedName(SERIALIZED_NAME_COMPONENTS)
  

  private IntlComponents components;

  /**
  * Get components
  * @return components
  **/
  
  @javax.annotation.Nullable
  
  @ApiModelProperty(value = &quot;&quot;)
  
  public IntlComponents getComponents() {
<span class="fc" id="L424">      return components;</span>
  }
  
  

  /**
   * Value is resource type.
   */
  @JsonAdapter(ObjectEnum.Adapter.class)
<span class="fc" id="L433">  public enum ObjectEnum {</span>
<span class="fc" id="L434">    INTL_VERIFICATION(&quot;intl_verification&quot;);</span>

    private String value;

<span class="fc" id="L438">    ObjectEnum(String value) {</span>
<span class="fc" id="L439">      this.value = value;</span>
<span class="fc" id="L440">    }</span>

    public String getValue() {
<span class="nc" id="L443">      return value;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L448">      return String.valueOf(value);</span>
    }

    public static ObjectEnum fromValue(String value) {
<span class="nc bnc" id="L452" title="All 2 branches missed.">      for (ObjectEnum b : ObjectEnum.values()) {</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">        if (b.value.equals(value)) {</span>
<span class="nc" id="L454">          return b;</span>
        }
      }
<span class="nc" id="L457">      throw new IllegalArgumentException(&quot;Unexpected value '&quot; + value + &quot;'&quot;);</span>
    }

<span class="nc" id="L460">    public static class Adapter extends TypeAdapter&lt;ObjectEnum&gt; {</span>
      @Override
      public void write(final JsonWriter jsonWriter, final ObjectEnum enumeration) throws IOException {
<span class="nc" id="L463">        jsonWriter.value(enumeration.getValue());</span>
<span class="nc" id="L464">      }</span>

      @Override
      public ObjectEnum read(final JsonReader jsonReader) throws IOException {
<span class="nc" id="L468">        String value =  jsonReader.nextString();</span>
<span class="nc" id="L469">        return ObjectEnum.fromValue(value);</span>
      }
    }
  }

  public static final String SERIALIZED_NAME_OBJECT = &quot;object&quot;;

  @SerializedName(SERIALIZED_NAME_OBJECT)
  

<span class="fc" id="L479">  private ObjectEnum _object = ObjectEnum.INTL_VERIFICATION;</span>

  /**
  * Value is resource type.
  * @return _object
  **/
  
  @javax.annotation.Nullable
  
  @ApiModelProperty(value = &quot;Value is resource type.&quot;)
  
  public ObjectEnum getObject() {
<span class="fc" id="L491">      return _object;</span>
  }
  
  


  /*
  public IntlVerification id(String id) {
    
    this.id = id;
    return this;
  }
  */





  /*
  public IntlVerification recipient(String recipient) {
    
    this.recipient = recipient;
    return this;
  }
  */


  public void setRecipient(String recipient) {
<span class="fc" id="L519">    this.recipient = recipient;</span>
<span class="fc" id="L520">  }</span>



  /*
  public IntlVerification primaryLine(String primaryLine) {
    
    this.primaryLine = primaryLine;
    return this;
  }
  */


  public void setPrimaryLine(String primaryLine) {
<span class="fc" id="L534">    this.primaryLine = primaryLine;</span>
<span class="fc" id="L535">  }</span>



  /*
  public IntlVerification secondaryLine(String secondaryLine) {
    
    this.secondaryLine = secondaryLine;
    return this;
  }
  */


  public void setSecondaryLine(String secondaryLine) {
<span class="fc" id="L549">    this.secondaryLine = secondaryLine;</span>
<span class="fc" id="L550">  }</span>



  /*
  public IntlVerification lastLine(String lastLine) {
    
    this.lastLine = lastLine;
    return this;
  }
  */


  public void setLastLine(String lastLine) {
<span class="fc" id="L564">    this.lastLine = lastLine;</span>
<span class="fc" id="L565">  }</span>



  /*
  public IntlVerification country(String country) {
    
    this.country = country;
    return this;
  }
  */


  public void setCountry(String country) {
<span class="fc" id="L579">    this.country = country;</span>
<span class="fc" id="L580">  }</span>



  /*
  public IntlVerification coverage(CoverageEnum coverage) {
    
    this.coverage = coverage;
    return this;
  }
  */


  public void setCoverage(CoverageEnum coverage) {
<span class="fc" id="L594">    this.coverage = coverage;</span>
<span class="fc" id="L595">  }</span>



  /*
  public IntlVerification deliverability(DeliverabilityEnum deliverability) {
    
    this.deliverability = deliverability;
    return this;
  }
  */


  public void setDeliverability(DeliverabilityEnum deliverability) {
<span class="fc" id="L609">    this.deliverability = deliverability;</span>
<span class="fc" id="L610">  }</span>



  /*
  public IntlVerification status(StatusEnum status) {
    
    this.status = status;
    return this;
  }
  */


  public void setStatus(StatusEnum status) {
<span class="fc" id="L624">    this.status = status;</span>
<span class="fc" id="L625">  }</span>



  /*
  public IntlVerification components(IntlComponents components) {
    
    this.components = components;
    return this;
  }
  */


  public void setComponents(IntlComponents components) {
<span class="fc" id="L639">    this.components = components;</span>
<span class="fc" id="L640">  }</span>



  /*
  public IntlVerification _object(ObjectEnum _object) {
    
    this._object = _object;
    return this;
  }
  */


  public void setObject(ObjectEnum _object) {
<span class="fc" id="L654">    this._object = _object;</span>
<span class="fc" id="L655">  }</span>



  @Override
  public boolean equals(Object o) {
<span class="nc bnc" id="L661" title="All 2 branches missed.">    if (this == o) {</span>
<span class="nc" id="L662">      return true;</span>
    }
<span class="nc bnc" id="L664" title="All 4 branches missed.">    if (o == null || getClass() != o.getClass()) {</span>
<span class="nc" id="L665">      return false;</span>
    }
<span class="nc" id="L667">    IntlVerification intlVerification = (IntlVerification) o;</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">    return Objects.equals(this.id, intlVerification.id) &amp;&amp;</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">        Objects.equals(this.recipient, intlVerification.recipient) &amp;&amp;</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">        Objects.equals(this.primaryLine, intlVerification.primaryLine) &amp;&amp;</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">        Objects.equals(this.secondaryLine, intlVerification.secondaryLine) &amp;&amp;</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">        Objects.equals(this.lastLine, intlVerification.lastLine) &amp;&amp;</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">        Objects.equals(this.country, intlVerification.country) &amp;&amp;</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">        Objects.equals(this.coverage, intlVerification.coverage) &amp;&amp;</span>
<span class="nc bnc" id="L675" title="All 2 branches missed.">        Objects.equals(this.deliverability, intlVerification.deliverability) &amp;&amp;</span>
<span class="nc bnc" id="L676" title="All 2 branches missed.">        Objects.equals(this.status, intlVerification.status) &amp;&amp;</span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">        Objects.equals(this.components, intlVerification.components) &amp;&amp;</span>
<span class="nc bnc" id="L678" title="All 2 branches missed.">        Objects.equals(this._object, intlVerification._object);</span>
  }

  private static &lt;T&gt; boolean equalsNullable(JsonNullable&lt;T&gt; a, JsonNullable&lt;T&gt; b) {
<span class="nc bnc" id="L682" title="All 12 branches missed.">    return a == b || (a != null &amp;&amp; b != null &amp;&amp; a.isPresent() &amp;&amp; b.isPresent() &amp;&amp; Objects.deepEquals(a.get(), b.get()));</span>
  }

  @Override
  public int hashCode() {
<span class="nc" id="L687">    return Objects.hash(id, recipient, primaryLine, secondaryLine, lastLine, country, coverage, deliverability, status, components, _object);</span>
  }

  private static &lt;T&gt; int hashCodeNullable(JsonNullable&lt;T&gt; a) {
<span class="nc bnc" id="L691" title="All 2 branches missed.">    if (a == null) {</span>
<span class="nc" id="L692">      return 1;</span>
    }
<span class="nc bnc" id="L694" title="All 2 branches missed.">    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;</span>
  }

  @Override
  public String toString() {
<span class="nc" id="L699">    StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L700">    sb.append(&quot;{\n&quot;);</span>
<span class="nc" id="L701">    sb.append(&quot;    id: &quot;).append(toIndentedString(id)).append(&quot;\n&quot;);</span>
<span class="nc" id="L702">    sb.append(&quot;    recipient: &quot;).append(toIndentedString(recipient)).append(&quot;\n&quot;);</span>
<span class="nc" id="L703">    sb.append(&quot;    primaryLine: &quot;).append(toIndentedString(primaryLine)).append(&quot;\n&quot;);</span>
<span class="nc" id="L704">    sb.append(&quot;    secondaryLine: &quot;).append(toIndentedString(secondaryLine)).append(&quot;\n&quot;);</span>
<span class="nc" id="L705">    sb.append(&quot;    lastLine: &quot;).append(toIndentedString(lastLine)).append(&quot;\n&quot;);</span>
<span class="nc" id="L706">    sb.append(&quot;    country: &quot;).append(toIndentedString(country)).append(&quot;\n&quot;);</span>
<span class="nc" id="L707">    sb.append(&quot;    coverage: &quot;).append(toIndentedString(coverage)).append(&quot;\n&quot;);</span>
<span class="nc" id="L708">    sb.append(&quot;    deliverability: &quot;).append(toIndentedString(deliverability)).append(&quot;\n&quot;);</span>
<span class="nc" id="L709">    sb.append(&quot;    status: &quot;).append(toIndentedString(status)).append(&quot;\n&quot;);</span>
<span class="nc" id="L710">    sb.append(&quot;    components: &quot;).append(toIndentedString(components)).append(&quot;\n&quot;);</span>
<span class="nc" id="L711">    sb.append(&quot;    _object: &quot;).append(toIndentedString(_object)).append(&quot;\n&quot;);</span>
<span class="nc" id="L712">    sb.append(&quot;}&quot;);</span>
<span class="nc" id="L713">    return sb.toString();</span>
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
<span class="nc bnc" id="L721" title="All 2 branches missed.">    if (o == null) {</span>
<span class="nc" id="L722">      return &quot;null&quot;;</span>
    }
<span class="nc" id="L724">    return o.toString().replace(&quot;\n&quot;, &quot;\n    &quot;);</span>
  }

}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>